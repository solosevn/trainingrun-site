<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TrainingRun HQ</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: #02060f;
  font-family: 'Courier New', monospace;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  overflow-x: hidden;
}

/* ══ HEADER ══ */
.hq-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 10px 28px;
  background: rgba(2,6,15,0.98);
  border-bottom: 1px solid rgba(0,212,255,0.15);
  flex-shrink: 0;
}
.logo-wrap { display: flex; align-items: center; gap: 12px; }
.logo-box {
  width: 32px; height: 32px; border-radius: 6px;
  background: linear-gradient(135deg, #001020, #002a45);
  border: 1px solid #00d4ff;
  display: flex; align-items: center; justify-content: center;
  font-size: 12px; font-weight: 900; color: #00d4ff;
  box-shadow: 0 0 12px rgba(0,212,255,0.3);
}
.logo-title { font-size: 13px; font-weight: 700; color: #fff; letter-spacing: 2px; }
.logo-sub   { font-size: 9px; letter-spacing: 3px; color: rgba(255,255,255,0.35); }

.hdr-right { display: flex; align-items: center; gap: 18px; }
.status-pill {
  display: flex; align-items: center; gap: 6px;
  background: rgba(0,212,255,0.05); border: 1px solid rgba(0,212,255,0.14);
  border-radius: 20px; padding: 4px 11px; font-size: 9.5px; color: rgba(255,255,255,0.4);
}
.sdot {
  width: 6px; height: 6px; border-radius: 50%;
  background: #222; transition: background .4s;
}
.sdot.on { background: #00d4ff; box-shadow: 0 0 6px #00d4ff; }
.hdr-clock { font-size: 10px; color: rgba(255,255,255,0.3); letter-spacing: 1px; }

/* ══ SCENE ══ */
.scene-wrap {
  flex: 1;
  display: flex; align-items: flex-start; justify-content: center;
  padding: 6px 0 0;
}
#stage { width: 100%; max-width: 1400px; }

/* ══ FOOTER CHIPS ══ */
.agent-line {
  text-align: center; padding: 3px 0 6px;
  font-size: 9.5px; letter-spacing: 2px; color: rgba(0,212,255,0.45);
}
.chips-row {
  display: flex; justify-content: center; gap: 8px;
  padding: 0 20px 14px; flex-wrap: wrap;
}
.chip {
  display: flex; align-items: center; gap: 6px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.06);
  border-radius: 7px; padding: 5px 12px;
  font-size: 9px; color: rgba(255,255,255,0.3);
}
.chip.on { border-color: rgba(0,212,255,0.2); color: rgba(255,255,255,0.6); }
.chip-dot { width: 6px; height: 6px; border-radius: 50%; background: #222; }

/* ══ CHARACTER ANIMATIONS ══ */
@keyframes bob   { 0%,100%{transform:translateY(0)}  50%{transform:translateY(-6px)} }
@keyframes type  { 0%,100%{transform:translateY(0) rotate(0deg)} 30%{transform:translateY(-3px) rotate(-2deg)} 70%{transform:translateY(-3px) rotate(2deg)} }
@keyframes jump  { 0%,100%{transform:translateY(0) scaleX(1)} 40%{transform:translateY(-10px) scaleX(1.05)} 80%{transform:translateY(-4px)} }
@keyframes wave  { 0%,100%{transform:rotate(0deg)} 25%{transform:rotate(-8deg)} 75%{transform:rotate(8deg)} }
@keyframes glow  { 0%,100%{filter:drop-shadow(0 0 7px rgba(0,212,255,.55))} 50%{filter:drop-shadow(0 0 18px rgba(0,212,255,.95))} }
@keyframes gold-glow { 0%,100%{filter:drop-shadow(0 0 6px rgba(255,215,0,.5))} 50%{filter:drop-shadow(0 0 14px rgba(255,215,0,.9))} }
@keyframes mflicker { 0%,91%,100%{opacity:1} 94%{opacity:.5} }

.c-idle    { animation: bob  2.8s ease-in-out infinite; }
.c-work    { animation: type 0.85s ease-in-out infinite; }
.c-jump    { animation: jump 1.1s ease-in-out infinite; }
.c-wave    { animation: wave 1.5s ease-in-out infinite; }
.c-sleep   { opacity:.35; }
.c-glow    { animation: glow 2.1s ease-in-out infinite; }
.c-gold    { animation: gold-glow 2s ease-in-out infinite; }
.mon-blink { animation: mflicker 10s ease-in-out infinite; }
svg text   { font-family:'Courier New',monospace; user-select:none; }
</style>
</head>
<body>

<!-- HEADER -->
<header class="hq-header">
  <div class="logo-wrap">
    <div class="logo-box">TR</div>
    <div>
      <div class="logo-title"><span style="color:#00d4ff">TRAINING</span>RUN HQ</div>
      <div class="logo-sub">MISSION CONTROL — <span style="color:#00d4ff">LIVE FEED</span></div>
    </div>
  </div>
  <div class="hdr-right">
    <div class="status-pill">
      <div class="sdot" id="sdot"></div>
      <span id="slabel">AGENT OFFLINE</span>
    </div>
    <div class="hdr-clock" id="clk">--:--:--</div>
  </div>
</header>

<!-- SCENE -->
<div class="scene-wrap">
  <svg id="stage" viewBox="0 0 1400 830" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <!-- Filters -->
      <filter id="f-cyan" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="5" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="f-warm" x="-50%" y="-50%" width="200%" height="200%">
        <feGaussianBlur stdDeviation="6" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="f-soft" x="-30%" y="-30%" width="160%" height="160%">
        <feGaussianBlur stdDeviation="3" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="f-glow2" x="-60%" y="-60%" width="220%" height="220%">
        <feGaussianBlur stdDeviation="8" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>

      <!-- Warm floor ambient glow gradient -->
      <radialGradient id="rg-warm" cx="50%" cy="50%" r="60%">
        <stop offset="0%"   stop-color="#FFD000" stop-opacity="0.18"/>
        <stop offset="70%"  stop-color="#FF8800" stop-opacity="0.06"/>
        <stop offset="100%" stop-color="#FF8800" stop-opacity="0"/>
      </radialGradient>
      <radialGradient id="rg-cyan" cx="50%" cy="50%" r="60%">
        <stop offset="0%"   stop-color="#00d4ff" stop-opacity="0.12"/>
        <stop offset="100%" stop-color="#00d4ff" stop-opacity="0"/>
      </radialGradient>
      <radialGradient id="rg-dim" cx="50%" cy="50%" r="60%">
        <stop offset="0%"   stop-color="#334466" stop-opacity="0.08"/>
        <stop offset="100%" stop-color="#334466" stop-opacity="0"/>
      </radialGradient>

      <!-- Denim texture (subtle) -->
      <pattern id="denim" x="0" y="0" width="4" height="4" patternUnits="userSpaceOnUse">
        <rect width="4" height="4" fill="#4A6FA5"/>
        <line x1="0" y1="2" x2="4" y2="2" stroke="#3d5f90" stroke-width="0.4"/>
        <line x1="2" y1="0" x2="2" y2="4" stroke="#3d5f90" stroke-width="0.3"/>
      </pattern>

      <!-- Chrome gradient for goggles -->
      <linearGradient id="lg-chrome" x1="0" y1="0" x2="0" y2="1">
        <stop offset="0%"  stop-color="#E8E8E8"/>
        <stop offset="40%" stop-color="#A8A8A8"/>
        <stop offset="100%" stop-color="#686868"/>
      </linearGradient>
      <linearGradient id="lg-chrome2" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%"  stop-color="#C8C8C8"/>
        <stop offset="50%" stop-color="#888888"/>
        <stop offset="100%" stop-color="#505050"/>
      </linearGradient>

      <!-- Floor tile grid pattern -->
      <pattern id="grid" x="0" y="0" width="42" height="21" patternUnits="userSpaceOnUse">
        <path d="M0,10.5 L21,0 L42,10.5 L21,21 Z" fill="none"
              stroke="rgba(0,212,255,0.05)" stroke-width="0.5"/>
      </pattern>
    </defs>

    <!-- Scene label -->
    <text x="700" y="20" text-anchor="middle"
          fill="rgba(0,212,255,0.25)" font-size="8.5" letter-spacing="5">
      TRAININGRUN HQ — FLOOR 01
    </text>

    <!-- LAYERS (painter's algorithm order) -->
    <g id="floors"></g>
    <g id="back-walls"></g>
    <g id="room-glow"></g>
    <g id="furniture"></g>
    <g id="front-walls"></g>
    <g id="chars"></g>
    <g id="labels"></g>
    <g id="holo"></g>
  </svg>
</div>

<!-- AGENT LINE -->
<div class="agent-line">
  TR MANAGER — <span id="agent-txt" style="color:rgba(255,255,255,.35)">OFFLINE</span>
</div>

<!-- DDP CHIPS -->
<div class="chips-row" id="chips"></div>

<script>
'use strict';
// ══════════════════════════════════════════════════
//  ISOMETRIC PROJECTION
//  Layout: 3 zones (left offices | center HQ | right future)
//  Left:  Web Manager (3×3, gx=0,gy=0) + DDP Ops (3×3, gx=0,gy=3.5)
//  Center: Main Agent HQ (6×6.5, gx=3.5,gy=0)  — covers full height
//  Right: TRS Arena (3×3, gx=10,gy=0) + Reserved (3×3, gx=10,gy=3.5)
// ══════════════════════════════════════════════════
const T  = 42;   // half-tile width (screen px per grid unit)
const H  = 21;   // half-tile height
const WH = 86;   // wall height in screen px
const OX = 542;  // scene origin screen X
const OY = 186;  // scene origin screen Y

function iso(gx, gy, gz = 0) {
  return { x: OX + (gx - gy) * T,  y: OY + (gx + gy) * H - gz };
}

// ══════════════════════════════════════════════════
//  SVG HELPERS
// ══════════════════════════════════════════════════
const NS = 'http://www.w3.org/2000/svg';
const $ = (id) => document.getElementById(id);

function el(tag, attrs = {}, text = null) {
  const e = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs)) e.setAttribute(k, String(v));
  if (text !== null) e.textContent = text;
  return e;
}
const G   = (a={}) => el('g', a);
const Txt = (x, y, s, a={}) => el('text', {x, y, ...a}, s);
const Cir = (cx, cy, r, a={}) => el('circle', {cx, cy, r, ...a});
const Ell = (cx, cy, rx, ry, a={}) => el('ellipse', {cx, cy, rx, ry, ...a});
const Rct = (x, y, w, h, a={}) => el('rect', {x, y, width:w, height:h, ...a});
const Pth = (d, a={}) => el('path', {d, ...a});
const Ln  = (x1,y1,x2,y2,a={}) => el('line', {x1,y1,x2,y2,...a});
const Poly= (pts,a={}) => el('polygon', {points: pts.map(p=>`${p.x},${p.y}`).join(' '), ...a});

function add(parent, ...children) { children.forEach(c => c && parent.appendChild(c)); }

// Four corners of a floor rhombus
function floorCorners(gx, gy, w, d) {
  return [iso(gx,gy), iso(gx+w,gy), iso(gx+w,gy+d), iso(gx,gy+d)];
}

// ══════════════════════════════════════════════════
//  GLASS ROOM BUILDER
//  — Digital Office aesthetic:
//    dark floor, warm glow overlay, glass walls
// ══════════════════════════════════════════════════
function buildRoom(gx, gy, w, d, opts = {}) {
  const {
    floorFill   = '#06101e',
    wallFill    = 'rgba(8,16,30,0.72)',
    strokeColor = '#00d4ff',
    strokeOp    = 0.4,
    glowGrad    = 'rg-warm',
    active      = true,
    dim         = false,   // fully inactive
  } = opts;

  const sc  = dim ? 'rgba(60,80,120,0.12)' : `rgba(${hex2rgb(strokeColor)},${strokeOp})`;
  const sw  = dim ? '0.6' : '1.4';
  const g   = G();

  // Floor
  add(g, Poly(floorCorners(gx,gy,w,d), {
    fill: dim ? '#04080e' : floorFill,
    stroke: sc, 'stroke-width': sw,
  }));

  // Warm ambient glow on floor (overlay)
  if (active && !dim) {
    const mid = iso(gx + w/2, gy + d/2);
    add(g, Ell(mid.x, mid.y, w*T*0.85, d*H*1.6, {
      fill: `url(#${glowGrad})`,
    }));
  }

  // Grid overlay on floor
  add(g, Poly(floorCorners(gx,gy,w,d), {
    fill: 'url(#grid)',
    opacity: dim ? '0.15' : (active ? '0.7' : '0.3'),
  }));

  // ─ WALLS ─
  // Back-left wall (top-left edge to top-right, facing south)
  const blTL = iso(gx,   gy, WH);
  const blTR = iso(gx+w, gy, WH);
  const blBL = iso(gx,   gy);
  const blBR = iso(gx+w, gy);
  add(g, Poly([blBL,blBR,blTR,blTL], {
    fill: wallFill, stroke: sc, 'stroke-width': sw,
  }));

  // Back-right wall (top-left edge to bottom-left, facing east)
  const brTL = iso(gx, gy,   WH);
  const brTR = iso(gx, gy+d, WH);
  const brBL = iso(gx, gy);
  const brBR = iso(gx, gy+d);
  add(g, Poly([brBL,brBR,brTR,brTL], {
    fill: wallFill, stroke: sc, 'stroke-width': sw,
  }));

  // ─ CEILING STRIP (subtle warm top edge) ─
  if (active && !dim) {
    const cTL = iso(gx,   gy,   WH);
    const cTR = iso(gx+w, gy,   WH);
    const cBL = iso(gx,   gy+d, WH);
    add(g,
      Pth(`M${cTL.x},${cTL.y} L${cTR.x},${cTR.y}`, {
        stroke: strokeColor, 'stroke-width': '1.2', opacity: '0.5', fill: 'none',
      }),
      Pth(`M${cTL.x},${cTL.y} L${cBL.x},${cBL.y}`, {
        stroke: strokeColor, 'stroke-width': '1', opacity: '0.35', fill: 'none',
      }),
    );
  }

  return g;
}

// Front walls drawn AFTER furniture (glass = see-through)
function buildFrontWalls(gx, gy, w, d, opts = {}) {
  const {
    wallFill    = 'rgba(6,14,26,0.55)',
    strokeColor = '#00d4ff',
    strokeOp    = 0.45,
    dim         = false,
  } = opts;
  const sc = dim ? 'rgba(60,80,120,0.1)' : `rgba(${hex2rgb(strokeColor)},${strokeOp})`;
  const sw = dim ? '0.6' : '1.4';
  const g  = G();

  // Front-left wall (bottom edge of room, facing west-south)
  const flTL = iso(gx,   gy+d, WH);
  const flTR = iso(gx+w, gy+d, WH);
  const flBL = iso(gx,   gy+d);
  const flBR = iso(gx+w, gy+d);
  add(g, Poly([flBL,flBR,flTR,flTL], {
    fill: wallFill, stroke: sc, 'stroke-width': sw,
  }));

  // Front-right wall (right edge of room, facing south-east)
  const frTL = iso(gx+w, gy,   WH);
  const frTR = iso(gx+w, gy+d, WH);
  const frBL = iso(gx+w, gy);
  const frBR = iso(gx+w, gy+d);
  add(g, Poly([frBL,frBR,frTR,frTL], {
    fill: wallFill, stroke: sc, 'stroke-width': sw,
  }));

  return g;
}

function hex2rgb(hex) {
  const r = parseInt(hex.slice(1,3),16);
  const g = parseInt(hex.slice(3,5),16);
  const b = parseInt(hex.slice(5,7),16);
  return `${r},${g},${b}`;
}

// ══════════════════════════════════════════════════
//  DESK + MONITOR  (isometric desk in room)
// ══════════════════════════════════════════════════
function buildDesk(gx, gy, opts = {}) {
  const { color = '#00d4ff', screenTxt = '▮', facing = 'left' } = opts;
  const g = G();
  const dw = 1.4, dd = 0.55, dh = 28;

  // Desk surface (floor face)
  add(g, Poly(floorCorners(gx, gy, dw, dd), {
    fill: '#0d1f32', stroke: color, 'stroke-width': '0.8', 'stroke-opacity': '0.55',
  }));
  // Desk front face (left wall of desk object)
  const dfTL = iso(gx,    gy+dd, dh);
  const dfTR = iso(gx+dw, gy+dd, dh);
  const dfBL = iso(gx,    gy+dd);
  const dfBR = iso(gx+dw, gy+dd);
  add(g, Poly([dfBL,dfBR,dfTR,dfTL], {
    fill: '#091625', stroke: color, 'stroke-width': '0.7', 'stroke-opacity': '0.4',
  }));
  // Desk right face
  const drTL = iso(gx+dw, gy,    dh);
  const drTR = iso(gx+dw, gy+dd, dh);
  const drBL = iso(gx+dw, gy);
  const drBR = iso(gx+dw, gy+dd);
  add(g, Poly([drBL,drBR,drTR,drTL], {
    fill: '#08141f', stroke: color, 'stroke-width': '0.7', 'stroke-opacity': '0.3',
  }));

  // Monitor (billboard sprite at desk top)
  const mBase = iso(gx + 0.5, gy + 0.12, dh);
  const mTop  = iso(gx + 0.5, gy + 0.08, dh + 40);
  // Stand
  add(g,
    Rct(mBase.x - 12, mBase.y - 4, 24, 6, {fill:'#1a2a3a', rx:'2', stroke:color,'stroke-width':'0.5','stroke-opacity':'0.4'}),
    Ln(mBase.x, mBase.y, mTop.x, mTop.y - 18, {stroke:color,'stroke-width':'1.5','stroke-opacity':'0.45'}),
    Rct(mTop.x - 22, mTop.y - 34, 44, 30, {fill:'#000d18', rx:'3', stroke:color,'stroke-width':'1.8',filter:'url(#f-cyan)',class:'mon-blink'}),
    Txt(mTop.x, mTop.y - 21, screenTxt, {fill:color,'font-size':'7','text-anchor':'middle',opacity:'0.9'}),
  );
  return g;
}

// Small filing cabinet
function buildCabinet(gx, gy) {
  const g = G();
  const cw=0.6, cd=0.5, ch=38;
  add(g,
    Poly(floorCorners(gx,gy,cw,cd), {fill:'#0e1e2e',stroke:'#335588','stroke-width':'0.7','stroke-opacity':'0.5'}),
    Poly([iso(gx,gy+cd,ch),iso(gx+cw,gy+cd,ch),iso(gx+cw,gy+cd),iso(gx,gy+cd)], {fill:'#0c1a28',stroke:'#335588','stroke-width':'0.6','stroke-opacity':'0.4'}),
    Poly([iso(gx+cw,gy,ch),iso(gx+cw,gy+cd,ch),iso(gx+cw,gy+cd),iso(gx+cw,gy)], {fill:'#0a1520',stroke:'#335588','stroke-width':'0.6','stroke-opacity':'0.35'}),
    Cir(iso(gx+cw*0.5,gy+cd,ch*0.55).x, iso(gx+cw*0.5,gy+cd,ch*0.55).y-2, 2, {fill:'#8ab0c8','fill-opacity':'0.7'}),
  );
  return g;
}

// Holographic display orb (floating)
function buildHolo(px, py, color, label) {
  const g = G({class:'c-wave'});
  add(g,
    Cir(px, py, 12, {fill:'none', stroke:color, 'stroke-width':'1', opacity:'0.5',filter:'url(#f-soft)'}),
    Cir(px, py, 7,  {fill:color, opacity:'0.15', filter:'url(#f-soft)'}),
    Cir(px, py, 3,  {fill:color, opacity:'0.7'}),
    Txt(px, py + 22, label, {fill:color,'font-size':'7','text-anchor':'middle',opacity:'0.7','letter-spacing':'1'}),
  );
  return g;
}

// ══════════════════════════════════════════════════
//  MOVIE-ACCURATE MINION CHARACTER
//  px, py = foot center position (screen coords)
//  scale 1.0 ≈ 105px tall
// ══════════════════════════════════════════════════
function buildMinion(px, py, opts = {}) {
  const {
    id          = 'm',
    scale       = 1.0,
    bodyColor   = '#F5C518',    // Minion yellow
    overallCol  = '#4A6FA5',    // denim blue
    accentColor = '#00d4ff',
    eyes        = 2,            // 1 or 2
    hairStyle   = 'spiky',      // 'spiky' | 'flat' | 'none'
    label       = '',
    labelColor  = '#00d4ff',
    animClass   = 'c-idle c-glow',
    happy       = true,
  } = opts;

  const S  = scale;
  const g  = G({id, class: animClass});

  // ─ MEASUREMENTS (all relative to py = foot) ─
  const legH  = 14 * S;
  const bodyW = 48 * S;   // body ellipse rx * 2
  const bodyRX = 23 * S;
  const bodyRY = 38 * S;  // pill shape
  // Body center: foot - legH - bodyRY + 12 (overlap with legs)
  const bodyCY = py - legH - bodyRY + 12 * S;
  const headCY = bodyCY - bodyRY * 0.55;  // head blends from body top
  const headRX = 22 * S;
  const headRY = 24 * S;

  // ─ SHADOW ─
  add(g, Ell(px, py + 4, 26*S, 7*S, {fill:'rgba(0,0,0,0.4)', filter:'url(#f-soft)'}));

  // ─ SHOES ─ (dark, slightly larger than feet)
  add(g,
    Ell(px - bodyRX * 0.5, py, 11*S, 5*S, {fill:'#111'}),
    Ell(px + bodyRX * 0.5, py, 11*S, 5*S, {fill:'#111'}),
  );

  // ─ LEGS ─
  add(g,
    Rct(px - bodyRX * 0.58, py - legH, 13*S, legH + 2, {fill:'#233045', rx: String(5*S)}),
    Rct(px + bodyRX * 0.58 - 13*S, py - legH, 13*S, legH + 2, {fill:'#233045', rx: String(5*S)}),
  );

  // ─ MAIN BODY (large yellow pill ellipse) ─
  // Body gradient: lighter at top, richer at center
  add(g, Ell(px, bodyCY, bodyRX, bodyRY, {fill: bodyColor}));

  // Body side highlight (right-side lighter strip)
  add(g, Ell(px + bodyRX * 0.35, bodyCY - bodyRY * 0.1, bodyRX * 0.35, bodyRY * 0.7, {
    fill: 'rgba(255,255,255,0.12)',
  }));

  // ─ HEAD (overlaps body top for seamless look) ─
  add(g, Ell(px, headCY, headRX, headRY, {fill: bodyColor}));
  // Head highlight
  add(g, Ell(px + headRX * 0.3, headCY - headRY * 0.15, headRX * 0.42, headRY * 0.55, {
    fill: 'rgba(255,255,255,0.14)',
  }));

  // ─ OVERALLS (denim, cover lower ~55% of body) ─
  const overBot  = bodyCY + bodyRY - 4*S;
  const overTop  = bodyCY + bodyRY * 0.02;   // just below equator
  const bibTop   = bodyCY - bodyRY * 0.2;     // bib goes higher than overalls
  const bibW     = bodyRX * 1.05;
  const bibH     = bibTop - overTop;

  // Pants body (clipped to lower body ellipse area)
  add(g, Rct(px - bibW * 0.9, overTop, bibW * 1.8, overBot - overTop, {
    fill: overallCol, rx: String(5*S),
  }));
  // Bib (front chest piece)
  add(g, Rct(px - bibW * 0.6, bibTop, bibW * 1.2, overTop - bibTop, {
    fill: overallCol, rx: String(4*S),
  }));

  // Bib lighter center highlight (denim fade)
  add(g, Rct(px - bibW * 0.38, bibTop + 3, bibW * 0.76, (overTop - bibTop) * 0.7, {
    fill: 'rgba(120,160,220,0.25)', rx: String(3*S),
  }));

  // Bib pocket (with G)
  const pkX = px - 7*S, pkY = overTop + 4*S;
  add(g,
    Rct(pkX, pkY, 14*S, 12*S, {fill:'rgba(60,90,140,0.8)', rx: String(2*S), stroke:'rgba(255,255,255,0.15)','stroke-width':'0.5'}),
    // G circle in pocket
    Cir(pkX + 7*S, pkY + 6*S, 4*S, {fill:'none', stroke:'rgba(255,255,255,0.35)', 'stroke-width':'1'}),
    Pth(`M${pkX+7*S},${pkY+4*S} L${pkX+10*S},${pkY+6*S} L${pkX+7*S},${pkY+6*S}`, {
      fill:'none', stroke:'rgba(255,255,255,0.35)', 'stroke-width':'0.8',
    }),
  );

  // Overall straps
  const strapW = 5 * S;
  const bibLeftX  = px - bibW * 0.6;
  const bibRightX = px + bibW * 0.6 - strapW;
  const shoulderY = headCY + headRY * 0.6;

  add(g,
    // Left strap
    Pth(`M${bibLeftX},${bibTop} L${px - bodyRX * 0.55},${shoulderY}`, {
      stroke: overallCol, 'stroke-width': String(strapW + 1),
      fill: 'none', 'stroke-linecap': 'round',
    }),
    // Right strap
    Pth(`M${bibRightX + strapW},${bibTop} L${px + bodyRX * 0.55},${shoulderY}`, {
      stroke: overallCol, 'stroke-width': String(strapW + 1),
      fill: 'none', 'stroke-linecap': 'round',
    }),
    // Left strap highlight
    Pth(`M${bibLeftX + strapW*0.3},${bibTop} L${px - bodyRX * 0.5 + 1},${shoulderY}`, {
      stroke: 'rgba(120,160,220,0.3)', 'stroke-width': String(strapW * 0.5),
      fill: 'none', 'stroke-linecap': 'round',
    }),
    // Buckle clips (small X squares)
    Rct(px - bodyRX * 0.6, shoulderY - 4, 7*S, 7*S, {fill:'#999', rx:'1'}),
    Rct(px + bodyRX * 0.6 - 7*S, shoulderY - 4, 7*S, 7*S, {fill:'#999', rx:'1'}),
    // Buckle X lines
    ...(() => {
      const items = [];
      for (const bx of [px - bodyRX * 0.6 + 3.5*S, px + bodyRX * 0.6 - 3.5*S]) {
        const by = shoulderY - 0.5;
        items.push(Ln(bx-2.5, by-2.5, bx+2.5, by+2.5, {stroke:'#333','stroke-width':'1.2'}));
        items.push(Ln(bx+2.5, by-2.5, bx-2.5, by+2.5, {stroke:'#333','stroke-width':'1.2'}));
      }
      return items;
    })(),
  );

  // ─ ARMS ─ (yellow, stubby)
  const armTopY = bodyCY - bodyRY * 0.25;
  const armLen  = 22 * S;

  // Left arm
  add(g,
    Rct(px - bodyRX - 9*S, armTopY, 10*S, armLen, {fill: bodyColor, rx: String(5*S)}),
    // Left hand (black mitten — 3 bumps)
    Ell(px - bodyRX - 4*S, armTopY + armLen, 9*S, 7*S, {fill:'#1a1a1a'}),
    Cir(px - bodyRX - 2*S, armTopY + armLen - 5*S, 3.5*S, {fill:'#252525'}),
    Cir(px - bodyRX - 6*S, armTopY + armLen - 3*S, 3*S,   {fill:'#252525'}),
    Cir(px - bodyRX - 9*S, armTopY + armLen - 1*S, 2.5*S, {fill:'#252525'}),
  );

  // Right arm
  add(g,
    Rct(px + bodyRX - 1*S, armTopY, 10*S, armLen, {fill: bodyColor, rx: String(5*S)}),
    Ell(px + bodyRX + 4*S, armTopY + armLen, 9*S, 7*S, {fill:'#1a1a1a'}),
    Cir(px + bodyRX + 2*S, armTopY + armLen - 5*S, 3.5*S, {fill:'#252525'}),
    Cir(px + bodyRX + 6*S, armTopY + armLen - 3*S, 3*S,   {fill:'#252525'}),
    Cir(px + bodyRX + 9*S, armTopY + armLen - 1*S, 2.5*S, {fill:'#252525'}),
  );

  // ─ HAIR ─
  if (hairStyle === 'spiky') {
    const hairData = [[-12*S, -22*S, -14*S, -38*S], [0, -26*S, 2*S, -42*S], [12*S, -22*S, 16*S, -36*S]];
    for (const [x1,y1,x2,y2] of hairData) {
      add(g, Pth(`M${px+x1},${headCY+y1*0.4} Q${px+(x1+x2)/2},${headCY+(y1+y2)*0.4} ${px+x2},${headCY+y2*0.5}`, {
        fill:'none', stroke:'#1a1008', 'stroke-width': String(4.5*S), 'stroke-linecap':'round',
      }));
    }
  } else if (hairStyle === 'flat') {
    add(g, Rct(px - headRX * 0.7, headCY - headRY - 4, headRX * 1.4, 10*S, {fill:'#1a1008', rx: String(3*S)}));
  }

  // ─ GOGGLE BAND (dark rubber strap around head) ─
  const bandY = headCY - headRY * 0.05;
  const bandH = 12 * S;
  add(g, Rct(px - headRX * 1.08, bandY - bandH/2, headRX * 2.16, bandH, {
    fill: '#111', rx: String(2*S),
  }));
  // Band highlights (rubber sheen)
  add(g,
    Rct(px - headRX * 1.0, bandY - bandH/2, headRX * 2.0, bandH * 0.3, {
      fill: 'rgba(255,255,255,0.06)', rx: String(1*S),
    }),
  );

  // ─ GOGGLES ─
  const gogCY = bandY;

  if (eyes === 1) {
    // Single large goggle
    const gr = 18 * S;
    add(g,
      // Outer chrome ring
      Cir(px, gogCY, gr, {fill:'url(#lg-chrome)'}),
      // Inner chrome shadow
      Cir(px, gogCY, gr * 0.82, {fill:'#5a5a5a'}),
      // Glass lens
      Cir(px, gogCY, gr * 0.75, {fill:'rgba(170,200,230,0.75)'}),
      // Glass inner shading
      Cir(px + gr*0.1, gogCY + gr*0.1, gr * 0.65, {fill:'rgba(120,170,210,0.4)'}),
      // Chrome shine arc (top)
      Pth(`M${px - gr*0.55},${gogCY - gr*0.68} A${gr*0.75},${gr*0.75} 0 0,1 ${px + gr*0.35},${gogCY - gr*0.68}`, {
        fill:'none', stroke:'rgba(255,255,255,0.55)', 'stroke-width': String(3*S), 'stroke-linecap':'round',
      }),
      // Iris (brown)
      Cir(px, gogCY, gr * 0.42, {fill:'#7A3E10'}),
      // Iris detail ring
      Cir(px, gogCY, gr * 0.35, {fill:'#8B4513'}),
      // Pupil
      Cir(px + gr*0.04, gogCY + gr*0.04, gr * 0.22, {fill:'#0a0a0a'}),
      // Pupil highlight
      Cir(px + gr*0.14, gogCY - gr*0.1, gr * 0.09, {fill:'#fff', opacity:'0.85'}),
      // Outer chrome frame bolts
      ...[-1,1].map(side => Cir(px + side*gr*0.95, gogCY, 1.8*S, {fill:'#ccc'})),
    );
  } else {
    // Two goggles
    const offsets = [-14*S, 14*S];
    const gr = 12 * S;
    for (const ox of offsets) {
      const gcx = px + ox;
      add(g,
        Cir(gcx, gogCY, gr, {fill:'url(#lg-chrome2)'}),
        Cir(gcx, gogCY, gr * 0.82, {fill:'#5a5a5a'}),
        Cir(gcx, gogCY, gr * 0.75, {fill:'rgba(170,200,230,0.75)'}),
        Cir(gcx + gr*0.1, gogCY + gr*0.1, gr * 0.65, {fill:'rgba(110,165,205,0.4)'}),
        Pth(`M${gcx - gr*0.55},${gogCY - gr*0.65} A${gr*0.75},${gr*0.75} 0 0,1 ${gcx + gr*0.3},${gogCY - gr*0.65}`, {
          fill:'none', stroke:'rgba(255,255,255,0.5)', 'stroke-width': String(2.5*S), 'stroke-linecap':'round',
        }),
        Cir(gcx, gogCY, gr * 0.44, {fill:'#7A3E10'}),
        Cir(gcx, gogCY, gr * 0.36, {fill:'#8B4513'}),
        Cir(gcx + gr*0.05, gogCY + gr*0.05, gr * 0.22, {fill:'#0a0a0a'}),
        Cir(gcx + gr*0.15, gogCY - gr*0.1, gr * 0.09, {fill:'#fff', opacity:'0.85'}),
      );
    }
    // Bridge between goggles
    add(g, Rct(px - 4*S, gogCY - 2.5*S, 8*S, 5*S, {fill:'url(#lg-chrome)', rx: String(1.5*S)}));
  }

  // ─ MOUTH ─
  const mouthCY = bodyCY + bodyRY * 0.28;
  const mW = 15 * S;
  const mH = happy ? 9 * S : 4 * S;

  if (happy) {
    // Wide open happy mouth
    add(g,
      // Outer lips / gum line
      Pth(`M${px - mW},${mouthCY} Q${px},${mouthCY + mH * 1.6} ${px + mW},${mouthCY}`, {
        fill:'#CC3030', 'stroke':'#9a2020', 'stroke-width': String(1.5*S),
      }),
      // Upper gum
      Pth(`M${px - mW + 2},${mouthCY + 1} L${px + mW - 2},${mouthCY + 1}`, {
        fill:'none', stroke:'#FF6060', 'stroke-width': String(2.5*S),
      }),
      // Teeth (3 blocks)
      ...[-1, 0, 1].map(t =>
        Rct(px + (t * 9*S) - 4*S, mouthCY + 1.5, 8*S, 6*S, {
          fill:'#F5F5F0', rx: String(1.5*S),
        })
      ),
      // Tongue hint
      Ell(px, mouthCY + mH * 1.0, 7*S, 5*S, {fill:'#DD4444', opacity:'0.8'}),
    );
  } else {
    // Slight smile
    add(g, Pth(`M${px - mW},${mouthCY} Q${px},${mouthCY + mH} ${px + mW},${mouthCY}`, {
      fill:'none', stroke:'#8a4020', 'stroke-width': String(2.5*S), 'stroke-linecap':'round',
    }));
  }

  // ─ LABEL ─
  if (label) {
    add(g, Txt(px, py + 18, label, {
      fill: labelColor, 'font-size': String(8.5*S), 'text-anchor':'middle',
      'letter-spacing': '1.5', opacity: '0.9',
    }));
  }

  return g;
}

// ══════════════════════════════════════════════════
//  MINI-MINION (DDP agents — scale ~0.58)
// ══════════════════════════════════════════════════
function buildMini(px, py, opts = {}) {
  return buildMinion(px, py, {
    scale: 0.57,
    hairStyle: 'none',
    eyes: 1,
    happy: true,
    animClass: 'c-idle',
    ...opts,
  });
}

// ══════════════════════════════════════════════════
//  ROOM DEFINITIONS
// ══════════════════════════════════════════════════
const RDEF = [
  {
    id:'web_manager', gx:0, gy:0, w:3, d:3,
    label:'TR WEB MANAGER', sub:'AGENT OFFICE',
    active:true, dim:false,
    strokeColor:'#00d4ff', glowGrad:'rg-cyan',
    floorFill:'#06101e', wallFill:'rgba(6,14,28,0.68)',
  },
  {
    id:'ddp_ops', gx:0, gy:3.5, w:3, d:2.5,
    label:'DDP OPERATIONS', sub:'5 AGENTS',
    active:true, dim:false,
    strokeColor:'#00d4ff', glowGrad:'rg-warm',
    floorFill:'#07100e', wallFill:'rgba(5,12,16,0.68)',
  },
  {
    id:'main_hq', gx:3.5, gy:0, w:6, d:6,
    label:'MAIN AGENT HQ', sub:'COMING SOON',
    active:false, dim:false,
    strokeColor:'#ffd700', glowGrad:'rg-dim',
    floorFill:'#070c16', wallFill:'rgba(8,12,24,0.70)',
  },
  {
    id:'trs_arena', gx:10, gy:0, w:3, d:3,
    label:'TRS ARENA', sub:'FUTURE',
    active:false, dim:true,
    strokeColor:'#9955ff', glowGrad:'rg-dim',
    floorFill:'#060810', wallFill:'rgba(6,8,18,0.72)',
  },
  {
    id:'reserved', gx:10, gy:3.5, w:3, d:2.5,
    label:'RESERVED', sub:'',
    active:false, dim:true,
    strokeColor:'#334466', glowGrad:'rg-dim',
    floorFill:'#050810', wallFill:'rgba(5,8,16,0.72)',
  },
];

// ══════════════════════════════════════════════════
//  DDP DATA
// ══════════════════════════════════════════════════
const DDPS = [
  {id:'trsbench', name:'TRSbench', color:'#00d4ff', bodyColor:'#F5C518', overallCol:'#154060'},
  {id:'trscode',  name:'TRScode',  color:'#00ee88', bodyColor:'#F5C518', overallCol:'#105038'},
  {id:'truscore', name:'TRUscore', color:'#aa66ff', bodyColor:'#F5C518', overallCol:'#2a1060'},
  {id:'trfcast',  name:'TRFcast',  color:'#ffd700', bodyColor:'#F5C518', overallCol:'#504010'},
  {id:'tragents', name:'TRAgents', color:'#ff4444', bodyColor:'#F5C518', overallCol:'#501010'},
];

// ══════════════════════════════════════════════════
//  BUILD SCENE
// ══════════════════════════════════════════════════
function buildScene() {
  const floors    = $('floors');
  const backWalls = $('back-walls');
  const glows     = $('room-glow');
  const furn      = $('furniture');
  const frontWs   = $('front-walls');
  const chars     = $('chars');
  const lbls      = $('labels');
  const holo      = $('holo');

  // Paint rooms back-to-front (gx+gy ascending)
  const sorted = [...RDEF].sort((a,b) => (a.gx+a.gy) - (b.gx+b.gy));

  const frontWallParts = [];

  for (const r of sorted) {
    // Floor + back walls
    floors.appendChild(buildRoom(r.gx, r.gy, r.w, r.d, r));

    // Front walls collected separately (drawn last, glass effect)
    frontWallParts.push({ r, gx:r.gx, gy:r.gy, w:r.w, d:r.d });

    // Room label on back wall top
    if (!r.dim) {
      const labelPt = iso(r.gx + r.w * 0.5, r.gy + 0.05, WH - 10);
      const subPt   = iso(r.gx + r.w * 0.5, r.gy + 0.05, WH - 22);
      add(lbls,
        Txt(labelPt.x, labelPt.y, r.label, {
          fill: r.active ? r.strokeColor : 'rgba(255,215,0,0.55)',
          'font-size': r.active ? '9' : '8',
          'text-anchor':'middle', 'letter-spacing':'2.5',
          filter: r.active ? 'url(#f-soft)' : undefined,
        }),
        r.sub ? Txt(subPt.x, subPt.y, r.sub, {
          fill: r.active ? 'rgba(255,255,255,0.4)' : 'rgba(255,215,0,0.25)',
          'font-size':'7', 'text-anchor':'middle', 'letter-spacing':'3',
        }) : null,
      );
    }
  }

  // ─ TR WEB MANAGER ROOM FURNITURE ─
  const wm = RDEF.find(r=>r.id==='web_manager');
  add(furn,
    buildDesk(wm.gx + 0.5, wm.gy + 0.3, {color:'#00d4ff', screenTxt:'status.json'}),
    buildDesk(wm.gx + 1.8, wm.gy + 0.3, {color:'#00aacc', screenTxt:'agent.py'}),
    buildCabinet(wm.gx + 2.5, wm.gy + 2.2),
  );

  // ─ DDP OPS ROOM FURNITURE ─
  const ddp = RDEF.find(r=>r.id==='ddp_ops');
  const ddpDeskPos = [
    {gx: ddp.gx + 0.1, gy: ddp.gy + 0.2},
    {gx: ddp.gx + 1.6, gy: ddp.gy + 0.2},
    {gx: ddp.gx + 0.6, gy: ddp.gy + 1.3},
    {gx: ddp.gx + 1.8, gy: ddp.gy + 1.3},
    {gx: ddp.gx + 0.1, gy: ddp.gy + 1.3},
  ];
  DDPS.forEach((d,i) => {
    if (ddpDeskPos[i])
      furn.appendChild(buildDesk(ddpDeskPos[i].gx, ddpDeskPos[i].gy, {color: d.color, screenTxt: d.name}));
  });

  // ─ MAIN HQ ROOM — empty throne + hologram ─
  const hq = RDEF.find(r=>r.id==='main_hq');
  const hqCenter = iso(hq.gx + hq.w/2, hq.gy + hq.d/2);
  // Central holographic orb
  add(holo,
    buildHolo(hqCenter.x, hqCenter.y - 25, '#ffd700', 'MAIN AGENT'),
    // Orbit ring
    Ell(hqCenter.x, hqCenter.y - 22, 35, 14, {
      fill:'none', stroke:'rgba(255,215,0,0.2)', 'stroke-width':'1',
      filter:'url(#f-soft)', class:'c-wave',
    }),
    // "Reserved" dim text on floor
    Txt(hqCenter.x, hqCenter.y + 8, 'AWAITING MAIN AGENT', {
      fill:'rgba(255,215,0,0.18)', 'font-size':'8.5',
      'text-anchor':'middle', 'letter-spacing':'3',
    }),
  );

  // ─ FRONT WALLS (glass, drawn over furniture) ─
  for (const { r, gx, gy, w, d } of frontWallParts) {
    frontWs.appendChild(buildFrontWalls(gx, gy, w, d, r));
  }

  // ─ MANAGER MINION in Web Manager office ─
  const manPt = iso(wm.gx + 1.5, wm.gy + 2.1);
  chars.appendChild(buildMinion(manPt.x, manPt.y, {
    id: 'mgr-minion',
    scale: 1.0,
    bodyColor: '#F5C518',
    overallCol: '#1e3e60',
    accentColor: '#00d4ff',
    eyes: 2,
    hairStyle: 'spiky',
    label: 'TR MANAGER',
    labelColor: '#00d4ff',
    animClass: 'c-idle c-glow',
    happy: true,
  }));

  // ─ DDP MINI-MINIONS in Ops room ─
  const miniPos = [
    {gx: ddp.gx + 0.5,  gy: ddp.gy + 1.0},
    {gx: ddp.gx + 1.3,  gy: ddp.gy + 0.9},
    {gx: ddp.gx + 2.1,  gy: ddp.gy + 1.0},
    {gx: ddp.gx + 0.7,  gy: ddp.gy + 2.1},
    {gx: ddp.gx + 1.8,  gy: ddp.gy + 2.0},
  ];
  DDPS.forEach((d, i) => {
    const p = miniPos[i];
    const sp = iso(p.gx, p.gy);
    chars.appendChild(buildMini(sp.x, sp.y, {
      id: `ddp-${d.id}`,
      bodyColor: d.bodyColor,
      overallCol: d.overallCol,
      accentColor: d.color,
      label: d.name,
      labelColor: d.color,
      animClass: 'c-idle',
    }));
  });

  // ─ ROOM DOOR MARKERS (connecting corridors) ─
  // Small cyan lines at doorways between connected rooms
  const doors = [
    // Web Manager ↔ Main HQ connector
    {from: iso(wm.gx+wm.w, wm.gy+wm.d/2, WH*0.7), to: iso(wm.gx+wm.w, wm.gy+wm.d/2, WH*0.1)},
    // DDP Ops ↔ Main HQ connector
    {from: iso(ddp.gx+ddp.w, ddp.gy+ddp.d/2, WH*0.7), to: iso(ddp.gx+ddp.w, ddp.gy+ddp.d/2, WH*0.1)},
  ];
  for (const d of doors) {
    add(lbls, Ln(d.from.x, d.from.y, d.to.x, d.to.y, {
      stroke:'rgba(0,212,255,0.5)', 'stroke-width':'2.5', 'stroke-linecap':'round',
      filter:'url(#f-soft)',
    }));
  }
}

// ══════════════════════════════════════════════════
//  DDP STATUS CHIPS
// ══════════════════════════════════════════════════
function buildChips(scores) {
  const row = $('chips');
  row.innerHTML = '';
  for (const d of DDPS) {
    const sc = scores[d.id] || null;
    const div = document.createElement('div');
    div.className = `chip${sc ? ' on' : ''}`;
    div.innerHTML = `
      <div class="chip-dot" style="${sc ? `background:${d.color};box-shadow:0 0 5px ${d.color}` : ''}"></div>
      <span style="font-weight:700;color:${sc ? d.color : 'rgba(255,255,255,0.2)'};">${d.name}</span>
      <span style="color:rgba(255,255,255,0.3);margin-left:4px;">${sc || '—'}</span>`;
    row.appendChild(div);
  }
}

// ══════════════════════════════════════════════════
//  LIVE DATA POLLING
// ══════════════════════════════════════════════════
let agentLive = false;

function setClass(id, cls) {
  const e = $(id);
  if (!e) return;
  e.classList.remove('c-idle','c-work','c-jump','c-wave','c-sleep');
  e.classList.add(cls);
  if (id === 'mgr-minion') {
    e.classList.toggle('c-glow', cls !== 'c-sleep');
  }
}

async function pollBridge() {
  try {
    const r = await fetch('http://localhost:7432/activity', {cache:'no-store'});
    if (!r.ok) throw new Error();
    const d = await r.json();
    agentLive = true;
    $('sdot').className  = 'sdot on';
    $('slabel').textContent = 'AGENT LIVE';
    $('agent-txt').textContent = d.action || 'STANDBY';

    const state = d.status;
    if (state === 'active') {
      setClass('mgr-minion', 'c-work');
      const act = (d.action||'').toLowerCase();
      for (const ddp of DDPS) {
        setClass(`ddp-${ddp.id}`, act.includes(ddp.id) ? 'c-jump' : 'c-idle');
      }
    } else if (state === 'waiting') {
      setClass('mgr-minion', 'c-wave');
    } else {
      setClass('mgr-minion', 'c-idle');
    }
  } catch {
    if (agentLive) {
      agentLive = false;
      $('sdot').className  = 'sdot';
      $('slabel').textContent = 'AGENT OFFLINE';
      $('agent-txt').textContent = 'OFFLINE';
      setClass('mgr-minion', 'c-sleep');
    }
  }
}

async function pollStatus() {
  try {
    const r = await fetch('status.json?t=' + Date.now());
    if (!r.ok) return;
    const d = await r.json();
    const sc = {};
    for (const [k, v] of Object.entries(d)) {
      const key = k.toLowerCase().replace(/[^a-z]/g,'');
      const ddp = DDPS.find(x => {
        const xi = x.id.replace(/[^a-z]/g,'');
        const xn = x.name.toLowerCase().replace(/[^a-z]/g,'');
        return xi===key || xn===key || key.includes(xi);
      });
      if (ddp) {
        const top = v.top5?.[0];
        sc[ddp.id] = top
          ? `${(top.model||top.name||'').split('/').pop()} ${top.score||''}`.trim()
          : (v.status||'');
      }
    }
    buildChips(sc);
  } catch { buildChips({}); }
}

function tick() {
  $('clk').textContent = new Date().toLocaleTimeString('en-US',{hour12:false});
}

// ══════════════════════════════════════════════════
//  INIT
// ══════════════════════════════════════════════════
buildScene();
buildChips({});
tick();
setInterval(tick, 1000);
setInterval(pollBridge, 3000);
setInterval(pollStatus, 30000);
pollBridge();
pollStatus();
</script>
</body>
</html>
