<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>TrainingRun HQ</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }

body {
  background: #020810;
  font-family: 'Courier New', monospace;
  min-height: 100vh;
  overflow-x: hidden;
  display: flex;
  flex-direction: column;
}

/* ── HEADER ── */
.hq-header {
  display: flex; align-items: center; justify-content: space-between;
  padding: 12px 28px;
  background: rgba(2,8,16,0.97);
  border-bottom: 1px solid rgba(0,212,255,0.18);
}
.logo-wrap { display: flex; align-items: center; gap: 12px; }
.logo-box {
  width: 34px; height: 34px; border-radius: 7px;
  background: linear-gradient(135deg, #001525, #003050);
  border: 1px solid #00d4ff;
  display: flex; align-items: center; justify-content: center;
  font-size: 13px; font-weight: 900; color: #00d4ff; letter-spacing: -1px;
  box-shadow: 0 0 14px rgba(0,212,255,0.35);
}
.logo-title { font-size: 13px; font-weight: 700; color: #fff; letter-spacing: 2px; }
.logo-sub   { font-size: 9px; letter-spacing: 3px; color: rgba(255,255,255,0.4); margin-top: 1px; }

.header-right { display: flex; align-items: center; gap: 20px; }
.bridge-pill {
  display: flex; align-items: center; gap: 7px;
  background: rgba(0,212,255,0.05); border: 1px solid rgba(0,212,255,0.15);
  border-radius: 20px; padding: 5px 12px; font-size: 10px; color: rgba(255,255,255,0.45);
}
.bridge-dot {
  width: 7px; height: 7px; border-radius: 50%;
  background: #333; transition: background 0.4s;
}
.bridge-dot.live { background: #00d4ff; box-shadow: 0 0 7px #00d4ff; }
.clock-display { font-size: 11px; color: rgba(255,255,255,0.35); letter-spacing: 1px; }

/* ── SCENE ── */
.scene-wrap {
  flex: 1;
  display: flex; align-items: flex-start; justify-content: center;
  padding: 8px 0 4px;
  overflow: hidden;
}
#iso-stage { width: 100%; max-width: 1400px; }

/* ── STATUS BAR ── */
.agent-bar {
  text-align: center;
  padding: 4px 20px 8px;
  font-size: 10px; letter-spacing: 2px;
  color: rgba(0,212,255,0.5);
}
#agent-action-text { color: rgba(255,255,255,0.4); }

/* ── DDP CHIPS ── */
.info-row {
  display: flex; justify-content: center;
  gap: 10px; padding: 0 20px 16px;
  flex-wrap: wrap;
}
.ddp-chip {
  display: flex; align-items: center; gap: 7px;
  background: rgba(255,255,255,0.02);
  border: 1px solid rgba(255,255,255,0.07);
  border-radius: 8px; padding: 6px 13px;
  font-size: 9px; color: rgba(255,255,255,0.35);
  transition: border-color 0.3s;
}
.ddp-chip .chip-dot { width: 7px; height: 7px; border-radius: 50%; background: #222; }
.ddp-chip.ok        { border-color: rgba(0,212,255,0.18); color: rgba(255,255,255,0.65); }
.chip-name          { font-weight: 700; }
.chip-score         { color: rgba(255,255,255,0.3); margin-left: 4px; }

/* ── CHARACTER ANIMATIONS ── */
@keyframes idle-bob {
  0%,100% { transform: translateY(0); }
  50%      { transform: translateY(-5px); }
}
@keyframes work-bounce {
  0%,100% { transform: translateY(0) rotate(0deg); }
  30%      { transform: translateY(-4px) rotate(-3deg); }
  70%      { transform: translateY(-4px) rotate(3deg); }
}
@keyframes glow-pulse {
  0%,100% { filter: drop-shadow(0 0 8px rgba(0,212,255,0.5)); }
  50%      { filter: drop-shadow(0 0 18px rgba(0,212,255,0.95)); }
}
@keyframes mon-flicker {
  0%,92%,100% { opacity:1; } 95% { opacity:0.55; }
}
.char-idle    { animation: idle-bob 2.8s ease-in-out infinite; }
.char-working { animation: work-bounce 0.9s ease-in-out infinite; }
.char-waiting { animation: idle-bob 4.5s ease-in-out infinite; opacity:0.65; }
.char-offline { opacity:0.2; }
.mgr-glow     { animation: glow-pulse 2.2s ease-in-out infinite; }
.mon-anim     { animation: mon-flicker 9s ease-in-out infinite; }

svg text { font-family:'Courier New',monospace; user-select:none; }
</style>
</head>
<body>

<!-- HEADER -->
<header class="hq-header">
  <div class="logo-wrap">
    <div class="logo-box">TR</div>
    <div>
      <div class="logo-title"><span style="color:#00d4ff">TRAINING</span>RUN HQ</div>
      <div class="logo-sub">OPERATIONS CENTER — <span style="color:#00d4ff">LIVE</span></div>
    </div>
  </div>
  <div class="header-right">
    <div class="bridge-pill">
      <div class="bridge-dot" id="bridge-dot"></div>
      <span id="bridge-label">AGENT OFFLINE</span>
    </div>
    <div class="clock-display" id="clock">--:--:--</div>
  </div>
</header>

<!-- ISOMETRIC SCENE -->
<div class="scene-wrap">
  <svg id="iso-stage" viewBox="0 0 1400 860" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <filter id="f-cyan" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="4" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="f-gold" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="5" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <filter id="f-soft" x="-25%" y="-25%" width="150%" height="150%">
        <feGaussianBlur stdDeviation="3" result="b"/>
        <feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
      <pattern id="floor-dots" x="0" y="0" width="38" height="19" patternUnits="userSpaceOnUse">
        <circle cx="19" cy="9.5" r="0.8" fill="rgba(0,212,255,0.12)"/>
      </pattern>
    </defs>

    <text x="700" y="22" text-anchor="middle"
          fill="rgba(0,212,255,0.3)" font-size="9" letter-spacing="5">
      TRAININGRUN HQ — FLOOR 01
    </text>

    <g id="world"></g>
    <g id="characters"></g>
    <g id="labels"></g>
  </svg>
</div>

<!-- AGENT BAR -->
<div class="agent-bar">
  TR MANAGER — <span id="agent-action-text">OFFLINE</span>
</div>

<!-- DDP CHIPS -->
<div class="info-row" id="ddp-chips"></div>

<script>
'use strict';
// ══════════════════════════════════════════════
//  ISOMETRIC PROJECTION PARAMS
//  3 cols × 2 rows, room size 4W × 3D
//  Layout fits within 1400×860 viewBox
// ══════════════════════════════════════════════
const TILE  = 38;    // half-tile width (px per grid unit, screen x)
const HTILE = 19;    // half-tile height (TILE/2)
const WALL  = 90;    // wall height in screen pixels
const OX    = 515;   // scene origin X
const OY    = 195;   // scene origin Y

// Room grid layout
const RW  = 4;    // room width  (x-axis)
const RD  = 3;    // room depth  (y-axis)
const GAP = 1.0;  // gap between rooms (grid units)

const COL0 = 0;
const COL1 = RW + GAP;   // 5.0
const COL2 = (RW + GAP) * 2; // 10.0

const ROW0 = 0;
const ROW1 = RD + GAP;   // 4.0

// iso(gx, gy, gz) → screen {x, y}
// gx: rightward axis, gy: forward axis, gz: elevation (up)
function iso(gx, gy, gz = 0) {
  return {
    x: OX + (gx - gy) * TILE,
    y: OY + (gx + gy) * HTILE - gz
  };
}

// ══════════════════════════════════════════════
//  PATH GENERATORS
// ══════════════════════════════════════════════
function pts(arr) {
  return arr.map(p => `${p.x},${p.y}`).join(' ');
}
function poly(points, attrs = {}) {
  const e = svgEl('polygon', { points: pts(points), ...attrs });
  return e;
}

// Floor rhombus: corners at (gx,gy), (gx+w,gy), (gx+w,gy+d), (gx,gy+d)
function floorPoly(gx, gy, w, d, attrs = {}) {
  return poly([
    iso(gx,   gy),
    iso(gx+w, gy),
    iso(gx+w, gy+d),
    iso(gx,   gy+d),
  ], attrs);
}

// Back-left wall (XZ plane at gy edge, looking toward +y)
function wallBackLeft(gx, gy, w, h, attrs = {}) {
  return poly([
    iso(gx,   gy),
    iso(gx+w, gy),
    iso(gx+w, gy, h),
    iso(gx,   gy, h),
  ], attrs);
}

// Back-right wall (YZ plane at gx edge, looking toward +x)
function wallBackRight(gx, gy, d, h, attrs = {}) {
  return poly([
    iso(gx, gy),
    iso(gx, gy+d),
    iso(gx, gy+d, h),
    iso(gx, gy,   h),
  ], attrs);
}

// Front-left wall (XZ plane at gy+d, visible to viewer)
function wallFrontLeft(gx, gy, w, d, h, attrs = {}) {
  return poly([
    iso(gx,   gy+d),
    iso(gx+w, gy+d),
    iso(gx+w, gy+d, h),
    iso(gx,   gy+d, h),
  ], attrs);
}

// Front-right wall (YZ plane at gx+w, visible to viewer)
function wallFrontRight(gx, gy, w, d, h, attrs = {}) {
  return poly([
    iso(gx+w, gy),
    iso(gx+w, gy+d),
    iso(gx+w, gy+d, h),
    iso(gx+w, gy,   h),
  ], attrs);
}

// ══════════════════════════════════════════════
//  SVG HELPERS
// ══════════════════════════════════════════════
const NS = 'http://www.w3.org/2000/svg';
function svgEl(tag, attrs = {}) {
  const e = document.createElementNS(NS, tag);
  for (const [k, v] of Object.entries(attrs)) e.setAttribute(k, String(v));
  return e;
}
function svgG(attrs = {}) { return svgEl('g', attrs); }
function svgText(x, y, str, attrs = {}) {
  const t = svgEl('text', { x, y, ...attrs });
  t.textContent = str;
  return t;
}
function svgLine(x1, y1, x2, y2, attrs = {}) {
  return svgEl('line', { x1, y1, x2, y2, ...attrs });
}
function svgRect(x, y, w, h, attrs = {}) {
  return svgEl('rect', { x, y, width: w, height: h, ...attrs });
}
function svgCircle(cx, cy, r, attrs = {}) {
  return svgEl('circle', { cx, cy, r, ...attrs });
}
function svgEllipse(cx, cy, rx, ry, attrs = {}) {
  return svgEl('ellipse', { cx, cy, rx, ry, ...attrs });
}
function svgPath(d, attrs = {}) {
  return svgEl('path', { d, ...attrs });
}
function appendAll(parent, ...children) {
  children.forEach(c => c && parent.appendChild(c));
}

// ══════════════════════════════════════════════
//  ROOM BUILDER
// ══════════════════════════════════════════════
function buildRoom(gx, gy, w, d, opts = {}) {
  const {
    floorFill  = '#0a1525',
    wallBL     = '#0d1e38',  // back-left
    wallBR     = '#091628',  // back-right
    wallFL     = '#0c1c35',  // front-left (visible)
    wallFR     = '#0a1a30',  // front-right (visible)
    accent     = '#00d4ff',
    accentOp   = 0.22,
    number     = '',
    label      = '',
    active     = true,
  } = opts;

  const g = svgG({ class: 'room' });
  const aO = active ? accentOp : 0.06;
  const aS = active ? `rgba(0,212,255,${aO})` : 'rgba(255,255,255,0.04)';
  const sw = '0.8';

  // Floor
  appendAll(g,
    floorPoly(gx, gy, w, d, { fill: floorFill, stroke: aS, 'stroke-width': sw }),
    floorPoly(gx, gy, w, d, { fill: 'url(#floor-dots)', opacity: active ? '0.9' : '0.2' }),

    // Back walls (draw first — behind everything)
    wallBackLeft(gx, gy, w, WALL, { fill: wallBL, stroke: aS, 'stroke-width': sw }),
    wallBackRight(gx, gy, d, WALL, { fill: wallBR, stroke: aS, 'stroke-width': sw }),

    // Ceiling edge (top ridge lines)
    ...(active ? [
      svgPath(`M${iso(gx,gy,WALL).x},${iso(gx,gy,WALL).y} L${iso(gx+w,gy,WALL).x},${iso(gx+w,gy,WALL).y}`,
        { stroke: accent, 'stroke-width': '1', opacity: '0.35', fill: 'none' }),
      svgPath(`M${iso(gx,gy,WALL).x},${iso(gx,gy,WALL).y} L${iso(gx,gy+d,WALL).x},${iso(gx,gy+d,WALL).y}`,
        { stroke: accent, 'stroke-width': '1', opacity: '0.25', fill: 'none' }),
    ] : []),

    // Front walls (on top — visible face)
    wallFrontLeft(gx, gy, w, d, WALL, { fill: wallFL, stroke: aS, 'stroke-width': sw }),
    wallFrontRight(gx, gy, w, d, WALL, { fill: wallFR, stroke: aS, 'stroke-width': sw }),
  );

  // Room number label (on back-left wall, top)
  if (number && active) {
    const np = iso(gx + 0.25, gy + 0.05, WALL - 12);
    appendAll(g,
      svgText(np.x, np.y, number, {
        fill: accent, 'font-size': '8', 'letter-spacing': '1', opacity: '0.5',
      })
    );
  }

  // Room label (on front-left wall center)
  if (label && active) {
    const lp = iso(gx + w * 0.5, gy + d, WALL * 0.52);
    appendAll(g,
      svgText(lp.x, lp.y, label, {
        fill: 'rgba(255,255,255,0.45)', 'font-size': '7.5', 'text-anchor': 'middle',
        'letter-spacing': '2.5',
      })
    );
  }

  return g;
}

// ══════════════════════════════════════════════
//  DESK + MONITOR
// ══════════════════════════════════════════════
function buildDesk(gx, gy, opts = {}) {
  const { color = '#00d4ff', screenText = '▮' } = opts;
  const g = svgG();

  const DW = 1.5, DD = 0.6, DH = 32;

  // Desk top face
  appendAll(g,
    floorPoly(gx, gy, DW, DD, {
      fill: '#0d1e30', stroke: color, 'stroke-width': '1', 'stroke-opacity': '0.5',
    }),
    // Desk front face
    wallFrontLeft(gx, gy, DW, DD, DH, {
      fill: '#091525', stroke: color, 'stroke-width': '0.8', 'stroke-opacity': '0.3',
    }),
    wallFrontRight(gx, gy, DW, DD, DH, {
      fill: '#07111f', stroke: color, 'stroke-width': '0.8', 'stroke-opacity': '0.25',
    }),
  );

  // Monitor stand
  const desk_top = iso(gx + 0.45, gy + 0.15, DH);
  const mon_top  = iso(gx + 0.45, gy + 0.1, DH + 38);

  appendAll(g,
    // Stand base
    svgRect(desk_top.x - 14, desk_top.y - 3, 28, 5, {
      fill: '#1a2a3a', rx: '2', stroke: color, 'stroke-width': '0.5', 'stroke-opacity': '0.4',
    }),
    // Stand pole
    svgLine(desk_top.x, desk_top.y, mon_top.x, mon_top.y - 22, {
      stroke: color, 'stroke-width': '1.5', 'stroke-opacity': '0.45',
    }),
    // Screen bezel
    svgRect(mon_top.x - 22, mon_top.y - 36, 44, 32, {
      fill: '#010d18', rx: '3', stroke: color, 'stroke-width': '1.8',
      filter: 'url(#f-cyan)', class: 'mon-anim',
    }),
    // Screen content
    svgText(mon_top.x, mon_top.y - 22, screenText, {
      fill: color, 'font-size': '7', 'text-anchor': 'middle', opacity: '0.85',
    }),
  );

  return g;
}

// ══════════════════════════════════════════════
//  LARGE MINION (Manager — ~130px tall)
// ══════════════════════════════════════════════
function buildMinion(px, py, opts = {}) {
  const {
    id          = 'minion',
    bodyColor   = '#f5c800',
    overallColor= '#1a3a5a',
    accentColor = '#00d4ff',
    glassColor  = '#a0e8ff',
    eyeCount    = 2,
    hairStyle   = 'spiky',
    label       = '',
    labelColor  = '#00d4ff',
    animClass   = 'char-idle',
  } = opts;

  const g = svgG({ id, class: animClass });
  const S = 1.1;

  // Measurements
  const BW = 40 * S, BH = 50 * S, HH = 42 * S, HW = 36 * S;
  const legH = 15 * S;
  const bodyY = py - legH - BH;
  const headY = bodyY - HH * 0.9;

  // Shadow
  appendAll(g,
    svgEllipse(px, py + 3, 22 * S, 5 * S, {
      fill: accentColor, opacity: '0.18', filter: 'url(#f-soft)',
    })
  );

  // Legs
  appendAll(g,
    svgRect(px - BW * 0.28 - 5, py - legH, 11 * S, legH, { fill: '#1a2540', rx: '4' }),
    svgRect(px + BW * 0.28 - 6, py - legH, 11 * S, legH, { fill: '#1a2540', rx: '4' }),
    svgEllipse(px - BW * 0.22, py, 9 * S, 3.5 * S, { fill: '#0d0d0d' }),
    svgEllipse(px + BW * 0.26, py, 9 * S, 3.5 * S, { fill: '#0d0d0d' }),
  );

  // Body (overalls)
  appendAll(g,
    svgRect(px - BW / 2, bodyY, BW, BH, { fill: overallColor, rx: String(7 * S) }),
    // Bib
    svgRect(px - BW * 0.2, bodyY + 4 * S, BW * 0.4, BH * 0.52, {
      fill: '#5a8ab0', rx: '5', opacity: '0.65',
    }),
    // Pocket seam
    svgLine(px - BW * 0.2, bodyY + BH * 0.3, px + BW * 0.2, bodyY + BH * 0.3, {
      stroke: 'rgba(255,255,255,0.12)', 'stroke-width': '0.8',
    }),
    // Buttons
    svgCircle(px - 4, bodyY + BH * 0.72, 2.2, { fill: '#c0d8ea' }),
    svgCircle(px + 4, bodyY + BH * 0.72, 2.2, { fill: '#c0d8ea' }),
  );

  // Arms
  appendAll(g,
    svgRect(px - BW / 2 - 9 * S, bodyY + 9, 9 * S, 26 * S, { fill: bodyColor, rx: '5' }),
    svgEllipse(px - BW / 2 - 4.5 * S, bodyY + 35 * S, 7 * S, 5.5 * S, { fill: bodyColor }),
    svgRect(px + BW / 2,          bodyY + 9, 9 * S, 26 * S, { fill: bodyColor, rx: '5' }),
    svgEllipse(px + BW / 2 + 4.5 * S, bodyY + 35 * S, 7 * S, 5.5 * S, { fill: bodyColor }),
  );

  // Head capsule
  appendAll(g,
    svgEllipse(px, headY + HH / 2, HW / 2, HH / 2, { fill: bodyColor }),
  );

  // Goggle band
  appendAll(g,
    svgRect(px - HW / 2, headY + HH * 0.3, HW, 11 * S, { fill: '#1a1a1a', rx: '2' }),
  );

  // Goggles
  if (eyeCount === 1) {
    const gc = px, gcY = headY + HH * 0.4;
    appendAll(g,
      svgEllipse(gc, gcY, 14 * S, 12 * S, { fill: '#111', stroke: '#777', 'stroke-width': '2' }),
      svgEllipse(gc, gcY, 9 * S, 8 * S, { fill: glassColor, opacity: '0.88' }),
      svgCircle(gc + 2, gcY + 1, 4.5 * S, { fill: '#111' }),
      svgCircle(gc + 3, gcY - 1, 2, { fill: '#fff', opacity: '0.8' }),
    );
  } else {
    for (const gx2 of [-(HW * 0.27), HW * 0.27]) {
      const gc = px + gx2, gcY = headY + HH * 0.4;
      appendAll(g,
        svgEllipse(gc, gcY, 10 * S, 9 * S, { fill: '#111', stroke: '#777', 'stroke-width': '2' }),
        svgEllipse(gc, gcY, 6.5 * S, 6.5 * S, { fill: glassColor, opacity: '0.88' }),
        svgCircle(gc + 1.5, gcY + 1, 3 * S, { fill: '#111' }),
        svgCircle(gc + 2.5, gcY - 0.5, 1.5, { fill: '#fff', opacity: '0.8' }),
      );
    }
    // Bridge
    appendAll(g,
      svgRect(px - 4, headY + HH * 0.4 - 1, 8, 2, { fill: '#555' }),
    );
  }

  // Smile
  const mY = headY + HH * 0.72;
  appendAll(g,
    svgPath(`M${px - 8 * S},${mY} Q${px},${mY + 7 * S} ${px + 8 * S},${mY}`, {
      fill: 'none', stroke: '#7a4a2a', 'stroke-width': '2.5', 'stroke-linecap': 'round',
    }),
  );

  // Hair
  if (hairStyle === 'spiky') {
    const hairs = [
      [px - 10, headY + 4, px - 14, headY - 20],
      [px,      headY + 2, px,      headY - 28],
      [px + 10, headY + 4, px + 12, headY - 22],
    ];
    for (const [x1,y1,x2,y2] of hairs) {
      appendAll(g,
        svgPath(`M${x1},${y1} Q${(x1+x2)/2},${(y1+y2)/2} ${x2},${y2}`, {
          fill: 'none', stroke: '#111', 'stroke-width': '4', 'stroke-linecap': 'round',
        }),
      );
    }
  }

  // Label
  if (label) {
    appendAll(g,
      svgText(px, py + 17, label, {
        fill: labelColor, 'font-size': '8', 'text-anchor': 'middle',
        'letter-spacing': '1', opacity: '0.85',
      }),
    );
  }

  return g;
}

// ══════════════════════════════════════════════
//  MINI MINION (DDP agents — ~75px tall)
// ══════════════════════════════════════════════
function buildMini(px, py, opts = {}) {
  const {
    id          = 'mini',
    bodyColor   = '#f5c800',
    overallColor= '#1a4060',
    accentColor = '#00d4ff',
    glassColor  = '#8cd4ff',
    label       = '',
    labelColor  = '#00d4ff',
    animClass   = 'char-idle',
    statusColor = '#00d4ff',
  } = opts;

  const g = svgG({ id, class: animClass });
  const S = 0.6;

  const BW = 40 * S, BH = 50 * S, HH = 42 * S, HW = 36 * S;
  const legH = 13 * S;
  const bodyY = py - legH - BH;
  const headY = bodyY - HH * 0.88;

  // Shadow
  appendAll(g,
    svgEllipse(px, py + 2, 13 * S, 3 * S, {
      fill: accentColor, opacity: '0.14', filter: 'url(#f-soft)',
    }),
  );

  // Legs
  appendAll(g,
    svgRect(px - BW * 0.28 - 3, py - legH, 8 * S, legH, { fill: '#1a2540', rx: '3' }),
    svgRect(px + BW * 0.28 - 5, py - legH, 8 * S, legH, { fill: '#1a2540', rx: '3' }),
    svgEllipse(px - BW * 0.2,  py, 7 * S, 2.8 * S, { fill: '#0d0d0d' }),
    svgEllipse(px + BW * 0.24, py, 7 * S, 2.8 * S, { fill: '#0d0d0d' }),
  );

  // Body
  appendAll(g,
    svgRect(px - BW / 2, bodyY, BW, BH, { fill: overallColor, rx: String(6 * S) }),
    svgRect(px - BW * 0.18, bodyY + 3 * S, BW * 0.36, BH * 0.5, {
      fill: '#5a8ab0', rx: '4', opacity: '0.6',
    }),
  );

  // Arms (small)
  appendAll(g,
    svgRect(px - BW / 2 - 7 * S, bodyY + 7, 7 * S, 21 * S, { fill: bodyColor, rx: '3' }),
    svgRect(px + BW / 2,          bodyY + 7, 7 * S, 21 * S, { fill: bodyColor, rx: '3' }),
  );

  // Head
  appendAll(g,
    svgEllipse(px, headY + HH / 2, HW / 2, HH / 2, { fill: bodyColor }),
    svgRect(px - HW / 2, headY + HH * 0.3, HW, 9 * S, { fill: '#1a1a1a', rx: '1.5' }),
    // Single goggle
    svgEllipse(px, headY + HH * 0.4, 11 * S, 9.5 * S, { fill: '#111', stroke: '#666', 'stroke-width': '1.5' }),
    svgEllipse(px, headY + HH * 0.4, 7.5 * S, 6.5 * S, { fill: glassColor, opacity: '0.85' }),
    svgCircle(px + 1, headY + HH * 0.41, 3.5 * S, { fill: '#111' }),
    svgCircle(px + 2, headY + HH * 0.38, 1.2, { fill: '#fff', opacity: '0.8' }),
    // Status dot on top
    svgCircle(px, headY, 3.5, { fill: statusColor, filter: 'url(#f-soft)' }),
  );

  // Label
  if (label) {
    appendAll(g,
      svgText(px, py + 13, label, {
        fill: labelColor, 'font-size': '6.5', 'text-anchor': 'middle', 'letter-spacing': '0.5',
      }),
    );
  }

  return g;
}

// ══════════════════════════════════════════════
//  ROOM DEFINITIONS
// ══════════════════════════════════════════════
const ROOMS = [
  // Row 0 (back)
  {
    id: 'manager_office',
    gx: COL0, gy: ROW0,
    label: 'MANAGER OFFICE', number: 'RM 01',
    active: true, accent: '#00d4ff',
    floorFill: '#0c1c30',
    wallBL: '#0e2040', wallBR: '#0a1830',
    wallFL: '#0d1e3e', wallFR: '#0b1a38',
  },
  {
    id: 'ddp_ops',
    gx: COL1, gy: ROW0,
    label: 'DDP OPERATIONS', number: 'RM 02',
    active: true, accent: '#00d4ff',
    floorFill: '#0a1828',
    wallBL: '#0c1d38', wallBR: '#091628',
    wallFL: '#0b1c36', wallFR: '#091530',
  },
  {
    id: 'trs_arena',
    gx: COL2, gy: ROW0,
    label: 'TRS ARENA', number: 'RM 03',
    active: false, accent: '#ffd700',
    floorFill: '#090d1c',
    wallBL: '#0b1020', wallBR: '#090e1a',
    wallFL: '#0a0f1e', wallFR: '#08111a',
  },
  // Row 1 (front)
  {
    id: 'content',
    gx: COL0, gy: ROW1,
    label: 'CONTENT STUDIO', number: 'RM 04',
    active: false, accent: '#ff3333',
    floorFill: '#0f0a14',
    wallBL: '#130c18', wallBR: '#100a14',
    wallFL: '#120b16', wallFR: '#0f0a12',
  },
  {
    id: 'social',
    gx: COL1, gy: ROW1,
    label: 'SOCIAL COMMAND', number: 'RM 05',
    active: false, accent: '#9955ff',
    floorFill: '#0d0a1a',
    wallBL: '#110d20', wallBR: '#0e0b1c',
    wallFL: '#100c1e', wallFR: '#0d0b1a',
  },
  {
    id: 'reserved',
    gx: COL2, gy: ROW1,
    label: 'RESERVED', number: 'RM 06',
    active: false, accent: '#333',
    floorFill: '#080c14',
    wallBL: '#090c16', wallBR: '#080a14',
    wallFL: '#090b15', wallFR: '#070913',
  },
];

// ══════════════════════════════════════════════
//  DDP DEFINITIONS
// ══════════════════════════════════════════════
const DDPS = [
  { id: 'trsbench', name: 'TRSbench', color: '#00d4ff', glass: '#a0e8ff', overall: '#144060' },
  { id: 'trscode',  name: 'TRScode',  color: '#00ee88', glass: '#88ffcc', overall: '#104038' },
  { id: 'truscore', name: 'TRUscore', color: '#aa66ff', glass: '#ddaaff', overall: '#30105a' },
  { id: 'trfcast',  name: 'TRFcast',  color: '#ffd700', glass: '#fff080', overall: '#504010' },
  { id: 'tragents', name: 'TRAgents', color: '#ff4444', glass: '#ffaaaa', overall: '#501010' },
];

// ══════════════════════════════════════════════
//  BUILD THE SCENE
// ══════════════════════════════════════════════
function buildScene() {
  const world = document.getElementById('world');
  const chars = document.getElementById('characters');
  const lbls  = document.getElementById('labels');

  // ── ROOMS (back-to-front: sorted by gx+gy) ──
  const sorted = [...ROOMS].sort((a, b) => (a.gx + a.gy) - (b.gx + b.gy));
  for (const r of sorted) {
    world.appendChild(buildRoom(r.gx, r.gy, RW, RD, r));
  }

  // ── MANAGER OFFICE DESKS ──
  const mgr = ROOMS.find(r => r.id === 'manager_office');
  world.appendChild(buildDesk(mgr.gx + 0.8,  mgr.gy + 0.4, { color: '#00d4ff', screenText: '> status' }));
  world.appendChild(buildDesk(mgr.gx + 2.4,  mgr.gy + 0.4, { color: '#0099cc', screenText: '> agent' }));

  // ── DDP OPS DESKS (5 desks for 5 DDPs) ──
  const ops = ROOMS.find(r => r.id === 'ddp_ops');
  const deskPositions = [
    { gx: ops.gx + 0.2, gy: ops.gy + 0.2 },
    { gx: ops.gx + 1.9, gy: ops.gy + 0.2 },
    { gx: ops.gx + 3.1, gy: ops.gy + 0.2 },  // note: 3.1 stays within room (4 wide)
    { gx: ops.gx + 0.6, gy: ops.gy + 1.6 },
    { gx: ops.gx + 2.4, gy: ops.gy + 1.6 },
  ];
  DDPS.forEach((ddp, i) => {
    const d = deskPositions[i];
    world.appendChild(buildDesk(d.gx, d.gy, { color: ddp.color, screenText: ddp.name }));
  });

  // ── MANAGER MINION ──
  const mgrPos = iso(mgr.gx + 1.9, mgr.gy + 2.0);
  chars.appendChild(buildMinion(mgrPos.x, mgrPos.y, {
    id:           'manager-minion',
    bodyColor:    '#f5c800',
    overallColor: '#143a5a',
    accentColor:  '#00d4ff',
    glassColor:   '#a0e8ff',
    eyeCount:     2,
    hairStyle:    'spiky',
    label:        'TR MANAGER',
    labelColor:   '#00d4ff',
    animClass:    'char-idle mgr-glow',
  }));

  // ── DDP MINI MINIONS in OPS ROOM ──
  const miniPositions = [
    { gx: ops.gx + 0.55, gy: ops.gy + 1.1 },
    { gx: ops.gx + 1.6,  gy: ops.gy + 1.1 },
    { gx: ops.gx + 2.7,  gy: ops.gy + 1.1 },
    { gx: ops.gx + 0.9,  gy: ops.gy + 2.5 },
    { gx: ops.gx + 2.4,  gy: ops.gy + 2.5 },
  ];

  DDPS.forEach((ddp, i) => {
    const p = miniPositions[i];
    const sp = iso(p.gx, p.gy);
    chars.appendChild(buildMini(sp.x, sp.y, {
      id:          `ddp-${ddp.id}`,
      bodyColor:   '#f5c800',
      overallColor: ddp.overall,
      accentColor: ddp.color,
      glassColor:  ddp.glass,
      label:       ddp.name,
      labelColor:  ddp.color,
      animClass:   'char-idle',
      statusColor: '#00d4ff',
    }));
  });

  // ── FUTURE ROOM SIGNS ──
  for (const r of ROOMS.filter(r => !r.active)) {
    const mid = iso(r.gx + RW / 2, r.gy + RD * 0.55, 24);
    appendAll(lbls,
      svgText(mid.x, mid.y, r.label, {
        fill: r.accent === '#333' ? 'rgba(60,60,60,0.5)' : r.accent + '55',
        'font-size': '8', 'text-anchor': 'middle', 'letter-spacing': '2.5',
      }),
      svgText(mid.x, mid.y + 13, 'COMING SOON', {
        fill: 'rgba(255,255,255,0.1)',
        'font-size': '6.5', 'text-anchor': 'middle', 'letter-spacing': '3',
      }),
    );
  }
}

// ══════════════════════════════════════════════
//  DDP CHIPS
// ══════════════════════════════════════════════
function buildChips(scores) {
  const row = document.getElementById('ddp-chips');
  row.innerHTML = '';
  for (const ddp of DDPS) {
    const score = scores[ddp.id] || null;
    const div = document.createElement('div');
    div.className = `ddp-chip${score ? ' ok' : ''}`;
    div.innerHTML = `
      <div class="chip-dot" style="${score ? `background:${ddp.color};box-shadow:0 0 5px ${ddp.color}` : ''}"></div>
      <span class="chip-name" style="color:${score ? ddp.color : 'rgba(255,255,255,0.2)'}">${ddp.name}</span>
      <span class="chip-score">${score || '—'}</span>
    `;
    row.appendChild(div);
  }
}

// ══════════════════════════════════════════════
//  LIVE DATA POLLING
// ══════════════════════════════════════════════
let bridgeOnline = false;
const BRIDGE_URL = 'http://localhost:7432/activity';
const STATUS_URL = 'status.json';

function setCharClass(id, cls) {
  const el = document.getElementById(id);
  if (!el) return;
  el.classList.remove('char-idle','char-working','char-waiting','char-offline');
  el.classList.add(cls);
  if (id === 'manager-minion') {
    el.classList.toggle('mgr-glow', cls !== 'char-offline');
  }
}

function setDdpGlowColor(ddpId, color) {
  const el = document.getElementById(`ddp-${ddpId}`);
  if (!el) return;
  const dot = el.querySelector('circle:last-of-type');
  if (dot) dot.setAttribute('fill', color);
}

async function pollBridge() {
  try {
    const r = await fetch(BRIDGE_URL, { cache: 'no-store' });
    if (!r.ok) throw new Error('not ok');
    const d = await r.json();

    bridgeOnline = true;
    document.getElementById('bridge-dot').className = 'bridge-dot live';
    document.getElementById('bridge-label').textContent = 'AGENT LIVE';
    document.getElementById('agent-action-text').textContent = d.action || 'STANDBY';

    if (d.status === 'active') {
      const loc = (d.location || '').toLowerCase();
      setCharClass('manager-minion', loc === 'ddp_room' ? 'char-working' : 'char-working');
      const act = (d.action || '').toLowerCase();
      DDPS.forEach(ddp => {
        if (act.includes(ddp.id) || act.includes(ddp.name.toLowerCase())) {
          setCharClass(`ddp-${ddp.id}`, 'char-working');
          setDdpGlowColor(ddp.id, '#ffd700');
        }
      });
    } else if (d.status === 'waiting') {
      setCharClass('manager-minion', 'char-waiting');
    } else {
      setCharClass('manager-minion', 'char-idle');
    }
  } catch {
    if (bridgeOnline) {
      bridgeOnline = false;
      document.getElementById('bridge-dot').className = 'bridge-dot';
      document.getElementById('bridge-label').textContent = 'AGENT OFFLINE';
      document.getElementById('agent-action-text').textContent = 'OFFLINE';
      setCharClass('manager-minion', 'char-offline');
    }
  }
}

async function pollStatus() {
  try {
    const r = await fetch(STATUS_URL + '?t=' + Date.now());
    if (!r.ok) return;
    const d = await r.json();
    const scores = {};
    for (const [rawKey, val] of Object.entries(d)) {
      const key = rawKey.toLowerCase().replace(/[^a-z]/g, '');
      const ddp = DDPS.find(x => {
        const xk = x.id.replace(/[^a-z]/g, '');
        const xn = x.name.toLowerCase().replace(/[^a-z]/g, '');
        return xk === key || xn === key || key.includes(xk) || xk.includes(key);
      });
      if (ddp) {
        const top = val.top5?.[0];
        const scoreText = top
          ? `${(top.model || top.name || '').split(' ').pop()} ${top.score || ''}`.trim()
          : (val.status || '');
        scores[ddp.id] = scoreText;
        // Update dot color based on status
        const dotColor = val.status === 'success' ? '#00d4ff'
                       : val.status === 'running' ? '#ffd700'
                       : '#333';
        setDdpGlowColor(ddp.id, dotColor);
        setCharClass(`ddp-${ddp.id}`, val.status === 'running' ? 'char-working' : 'char-idle');
      }
    }
    buildChips(scores);
  } catch {
    buildChips({});
  }
}

// ══════════════════════════════════════════════
//  CLOCK
// ══════════════════════════════════════════════
function tick() {
  document.getElementById('clock').textContent =
    new Date().toLocaleTimeString('en-US', { hour12: false });
}

// ══════════════════════════════════════════════
//  INIT
// ══════════════════════════════════════════════
buildScene();
buildChips({});
tick();
setInterval(tick, 1000);
setInterval(pollBridge, 3000);
setInterval(pollStatus, 30000);
pollBridge();
pollStatus();
</script>
</body>
</html>
